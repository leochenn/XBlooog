[TOC]

# 优化

## 超时优化

>  问题场景：客户端视为超时的请求，最终被服务端接收成功并处理！！！
>
> 客户端的注册账号功能，自动分配了账号密码，用户提交注册时，若当前网络状况不良，请求时间过长，则会被客户端视为超时，而服务端可能正常接收到请求并进行了处理；用户第二次点击注册进行重试时，服务端会判断该账号已经注册，无法正常注册并进行到下一步，十分影响体验

- 方案一
  - 准备工作
    - 初始化时[同步服务器时间](#同步服务器时间)
    - 客户端的请求增加俩个参数：当前客户端保存的服务器时间，客户端设置的请求超时的时长
    - 服务端返回的结果增加一个参数：当前服务器时间
  - 执行请求
    - 客户端提交请求
    - 服务端接收到请求后，判断请求参数是否有服务器时间以及超时时长，若有则进行判断
      1. 服务端记录接收到该请求后的时间，并与请求参数中的服务器时间相减，差值若大于请求参数中的超时时长，则返回超时的结果，否则进入b
      2. 服务端在处理请求完成，记录当前时间，并与请求参数中的服务器时间相减，差值若大于请求参数中的超时时长，则返回超时的结果，否则正常返回
  - 减小误差：考虑到服务端的结果返回到客户端存在耗时， 请求参数中带的超时时长可以略小于客户端设置的实际请求超时时长
  - 代价：同步服务器时间存在误差，服务端返回结果、客户端读取到response存在耗时， 该方案并不能彻底解决问题，只能在某种程度上减少出错的情况
- 方案二
  - 客户端：第一次提交请求，对应一个id（结合当前时间以及当前场景）；当超时后再次发起，则以同样的id进行请求
  - 服务端：接收到第一次请求时，（每个账号、或者当前设备等等，视场景而定）保存当前请求id以及对应的返回结果；当接收到相同id的请求时，返回上次的结果
  - 代价：请求结果都需要进行缓存；如果出现不同场景生成同样的id，或者同样场景下生成不同的id，或者服务端保存的结果对应的条件出现偏差，都可能判断失误
- 若俩种方案结合，则可以提升优化效果



## 同步服务器时间

[参考库实现](<https://github.com/qinci/ServerTimeTest>)

1. SystemClock.elapsedRealtime() ：手机系统开机时间（包含睡眠时间），用户无法在设置里面修改
2. 在必要的时刻获取一下服务器时间，然后记录这个时刻的手机开机时间（elapsedRealtime）以及请求耗时时间，用于优化
3. 后续时间获取：现在服务器时间 = 以前服务器时间 + 现在手机开机时间 - 以前服务器时间的获取时刻的手机开机时间



优化

1. 网络响应头包含Date字段（世界时间）
2. 利用Interceptor记录每次请求响应时间，如果本次网络操作的时间小于上一次请求耗时时间，则获取Date字段，更新本地保存的服务器时间。
3. 这样时间就只会越来越精确



# 调试相关

## 工具

- Charles 抓包工具
- PostMan 模拟发送请求
- [Mocky](<https://www.mocky.io/>) 模拟返回结果
- [YAPI](<http://yapi.demo.qunar.com/project/68450/data>) 管理api接口

- 本地服务器模拟
  - 使用Python开启本地服务
  - HFS本地文件服务器
  - java-io.netty库实现 [jsonHttpServer](./extra/jsonHttpServer.zip)